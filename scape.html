<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DreamScape - Interactive Idea Board</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/framer-motion@10.16.4/dist/framer-motion.js"></script>
    <script src="https://unpkg.com/react-colorful@5.6.1/dist/index.js"></script>
    <script src="https://unpkg.com/html-to-image@1.11.11/dist/html-to-image.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            touch-action: none;
        }
        
        .particle-aura {
            position: absolute;
            width: 120%;
            height: 120%;
            top: -10%;
            left: -10%;
            border-radius: 8px;
            opacity: 0.3;
            z-index: -1;
            transition: all 0.3s ease;
        }
        
        .note-shadow {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        
        .note-shadow-dark {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.2);
        }
        
        .glow-line {
            position: absolute;
            pointer-events: none;
            stroke-width: 2;
            stroke-linecap: round;
            filter: drop-shadow(0 0 2px currentColor);
        }
        
        .flip-card {
            perspective: 1000px;
        }
        
        .flip-card-inner {
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }
        
        .flip-card.flipped .flip-card-inner {
            transform: rotateY(180deg);
        }
        
        .flip-card-front, .flip-card-back {
            backface-visibility: hidden;
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        .flip-card-back {
            transform: rotateY(180deg);
        }
        
        .pulse-highlight {
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 215, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); }
        }
        
        .canvas-bg {
            background-size: 40px 40px;
            background-image: linear-gradient(to right, rgba(0, 0, 0, 0.05) 1px, transparent 1px),
                              linear-gradient(to bottom, rgba(0, 0, 0, 0.05) 1px, transparent 1px);
        }
        
        .canvas-bg-dark {
            background-image: linear-gradient(to right, rgba(255, 255, 255, 0.05) 1px, transparent 1px),
                              linear-gradient(to bottom, rgba(255, 255, 255, 0.05) 1px, transparent 1px);
        }
        
        .chalkboard-text {
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 2px #fff;
            letter-spacing: 1px;
        }
        
        .neon-border {
            box-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #0ff, 0 0 20px #0ff;
        }
    </style>
</head>
<body class="bg-white dark:bg-gray-900 transition-colors duration-300">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;
        const { motion, AnimatePresence } = window.Motion;
        const { HexColorPicker } = window.ReactColorful;
        
        // Pastel color palette
        const COLORS = [
            '#FFD6E0', '#FFEFD6', '#FFFFD6', '#E0FFD6', 
            '#D6FFEF', '#D6FFFF', '#D6E0FF', '#EFD6FF',
            '#FFD6FF', '#FFD6E0'
        ];
        
        const NEON_COLORS = [
            '#ff00ff', '#00ffff', '#ffff00', '#ff00aa',
            '#00ffaa', '#aa00ff', '#ffaa00', '#00aaff'
        ];
        
        const Note = React.forwardRef(({ 
            id, 
            x, 
            y, 
            width, 
            height, 
            rotation, 
            color, 
            content, 
            isSelected, 
            isHighlighted, 
            isDarkMode,
            onMouseDown, 
            onDoubleClick,
            onResize,
            onDelete,
            onColorChange,
            onContentChange
        }, ref) => {
            const [isHovered, setIsHovered] = useState(false);
            const [isEditing, setIsEditing] = useState(false);
            const [showColorPicker, setShowColorPicker] = useState(false);
            const textareaRef = useRef(null);
            
            const handleDoubleClick = (e) => {
                e.stopPropagation();
                setIsEditing(true);
                setTimeout(() => {
                    textareaRef.current?.focus();
                }, 0);
            };
            
            const handleBlur = () => {
                setIsEditing(false);
            };
            
            const handleKeyDown = (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    setIsEditing(false);
                }
            };
            
            const handleColorChange = (newColor) => {
                onColorChange(id, newColor);
            };
            
            const toggleColorPicker = (e) => {
                e.stopPropagation();
                setShowColorPicker(!showColorPicker);
            };
            
            const handleDelete = (e) => {
                e.stopPropagation();
                onDelete(id);
            };
            
            const resizeHandleMouseDown = (e, direction) => {
                e.stopPropagation();
                onResize(e, id, direction);
            };
            
            return (
                <motion.div
                    ref={ref}
                    className={`absolute cursor-move ${isDarkMode ? 'note-shadow-dark' : 'note-shadow'} ${isHighlighted ? 'pulse-highlight' : ''}`}
                    style={{
                        x,
                        y,
                        width,
                        height,
                        rotate: rotation,
                        backgroundColor: isDarkMode ? (color === '#FFFFFF' ? '#1F2937' : color) : color,
                        zIndex: isSelected ? 100 : 10,
                        border: isDarkMode ? `1px solid ${NEON_COLORS[COLORS.indexOf(color)] || '#00ffff'}` : '1px solid rgba(0,0,0,0.1)'
                    }}
                    initial={{ scale: 0.8, opacity: 0 }}
                    animate={{ scale: 1, opacity: 1 }}
                    exit={{ scale: 0.5, opacity: 0 }}
                    transition={{ type: 'spring', damping: 20, stiffness: 300 }}
                    onMouseDown={(e) => onMouseDown(e, id)}
                    onDoubleClick={onDoubleClick}
                    onHoverStart={() => setIsHovered(true)}
                    onHoverEnd={() => setIsHovered(false)}
                    drag
                    dragMomentum={false}
                    dragElastic={0.1}
                    whileDrag={{ scale: 1.05, zIndex: 100 }}
                >
                    <div className={`particle-aura ${isHovered ? 'opacity-50' : 'opacity-30'}`} 
                         style={{ backgroundColor: isDarkMode ? NEON_COLORS[COLORS.indexOf(color)] || '#00ffff' : color }} />
                    
                    <div className="absolute inset-0 p-3 flex flex-col">
                        {isEditing ? (
                            <textarea
                                ref={textareaRef}
                                className={`w-full h-full bg-transparent outline-none resize-none ${isDarkMode ? 'text-white chalkboard-text' : 'text-gray-800'}`}
                                value={content}
                                onChange={(e) => onContentChange(id, e.target.value)}
                                onBlur={handleBlur}
                                onKeyDown={handleKeyDown}
                                autoFocus
                            />
                        ) : (
                            <div 
                                className={`w-full h-full overflow-auto ${isDarkMode ? 'text-white chalkboard-text' : 'text-gray-800'}`}
                                dangerouslySetInnerHTML={{ __html: content.replace(/\n/g, '<br>') }}
                            />
                        )}
                    </div>
                    
                    {isSelected && (
                        <>
                            {/* Resize handles */}
                            <div 
                                className="absolute w-3 h-3 bg-white rounded-full border border-gray-400 cursor-nwse-resize -left-1.5 -top-1.5"
                                onMouseDown={(e) => resizeHandleMouseDown(e, 'nw')}
                            />
                            <div 
                                className="absolute w-3 h-3 bg-white rounded-full border border-gray-400 cursor-ns-resize -top-1.5 left-1/2 -translate-x-1/2"
                                onMouseDown={(e) => resizeHandleMouseDown(e, 'n')}
                            />
                            <div 
                                className="absolute w-3 h-3 bg-white rounded-full border border-gray-400 cursor-nesw-resize -right-1.5 -top-1.5"
                                onMouseDown={(e) => resizeHandleMouseDown(e, 'ne')}
                            />
                            <div 
                                className="absolute w-3 h-3 bg-white rounded-full border border-gray-400 cursor-ew-resize -right-1.5 top-1/2 -translate-y-1/2"
                                onMouseDown={(e) => resizeHandleMouseDown(e, 'e')}
                            />
                            <div 
                                className="absolute w-3 h-3 bg-white rounded-full border border-gray-400 cursor-nwse-resize -right-1.5 -bottom-1.5"
                                onMouseDown={(e) => resizeHandleMouseDown(e, 'se')}
                            />
                            <div 
                                className="absolute w-3 h-3 bg-white rounded-full border border-gray-400 cursor-ns-resize -bottom-1.5 left-1/2 -translate-x-1/2"
                                onMouseDown={(e) => resizeHandleMouseDown(e, 's')}
                            />
                            <div 
                                className="absolute w-3 h-3 bg-white rounded-full border border-gray-400 cursor-nesw-resize -left-1.5 -bottom-1.5"
                                onMouseDown={(e) => resizeHandleMouseDown(e, 'sw')}
                            />
                            <div 
                                className="absolute w-3 h-3 bg-white rounded-full border border-gray-400 cursor-ew-resize -left-1.5 top-1/2 -translate-y-1/2"
                                onMouseDown={(e) => resizeHandleMouseDown(e, 'w')}
                            />
                            
                            {/* Rotate handle */}
                            <div 
                                className="absolute w-3 h-3 bg-white rounded-full border border-gray-400 cursor-grab -left-1.5 top-1/2 -translate-y-1/2 -translate-x-3"
                                onMouseDown={(e) => resizeHandleMouseDown(e, 'rotate')}
                            />
                            
                            {/* Toolbar */}
                            <div className="absolute -top-8 left-0 flex gap-1">
                                <button 
                                    className={`w-6 h-6 rounded-full flex items-center justify-center ${isDarkMode ? 'bg-gray-800 text-white' : 'bg-white text-gray-800'}`}
                                    onClick={toggleColorPicker}
                                >
                                    <i className="fas fa-palette text-xs"></i>
                                </button>
                                <button 
                                    className={`w-6 h-6 rounded-full flex items-center justify-center ${isDarkMode ? 'bg-gray-800 text-white' : 'bg-white text-gray-800'}`}
                                    onClick={handleDelete}
                                >
                                    <i className="fas fa-trash text-xs"></i>
                                </button>
                            </div>
                            
                            {showColorPicker && (
                                <div className="absolute -top-48 left-0 z-50">
                                    <HexColorPicker color={color} onChange={handleColorChange} />
                                </div>
                            )}
                        </>
                    )}
                </motion.div>
            );
        });
        
        const ConnectionLine = ({ from, to, color }) => {
            const pathRef = useRef(null);
            
            useEffect(() => {
                if (pathRef.current && from && to) {
                    const fromRect = from.getBoundingClientRect();
                    const toRect = to.getBoundingClientRect();
                    
                    const fromX = fromRect.left + fromRect.width / 2;
                    const fromY = fromRect.top + fromRect.height / 2;
                    const toX = toRect.left + toRect.width / 2;
                    const toY = toRect.top + toRect.height / 2;
                    
                    // Calculate control points for a smooth curve
                    const dx = toX - fromX;
                    const dy = toY - fromY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const controlX1 = fromX + dx * 0.3;
                    const controlY1 = fromY + dy * 0.3 + distance * 0.2;
                    const controlX2 = toX - dx * 0.3;
                    const controlY2 = toY - dy * 0.3 - distance * 0.2;
                    
                    const pathData = `M${fromX},${fromY} C${controlX1},${controlY1} ${controlX2},${controlY2} ${toX},${toY}`;
                    
                    pathRef.current.setAttribute('d', pathData);
                    pathRef.current.style.stroke = color;
                }
            }, [from, to, color]);
            
            return (
                <svg className="glow-line" style={{ width: '100%', height: '100%' }}>
                    <path ref={pathRef} fill="none" />
                </svg>
            );
        };
        
        const DreamScape = () => {
            const [notes, setNotes] = useState([]);
            const [connections, setConnections] = useState([]);
            const [selectedNoteId, setSelectedNoteId] = useState(null);
            const [isConnecting, setIsConnecting] = useState(false);
            const [connectionStartId, setConnectionStartId] = useState(null);
            const [searchQuery, setSearchQuery] = useState('');
            const [isDarkMode, setIsDarkMode] = useState(false);
            const [viewMode, setViewMode] = useState('board'); // 'board' or 'mindmap'
            const [scale, setScale] = useState(1);
            const [position, setPosition] = useState({ x: 0, y: 0 });
            const [isDraggingCanvas, setIsDraggingCanvas] = useState(false);
            const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
            const [noteCounter, setNoteCounter] = useState(1);
            const [flippedNoteId, setFlippedNoteId] = useState(null);
            
            const canvasRef = useRef(null);
            const noteRefs = useRef({});
            
            // Initialize with some sample notes
            useEffect(() => {
                const initialNotes = [
                    {
                        id: 'note-1',
                        x: 100,
                        y: 100,
                        width: 200,
                        height: 150,
                        rotation: -3,
                        color: COLORS[0],
                        content: 'Welcome to DreamScape!\n\nDouble click to edit notes.'
                    },
                    {
                        id: 'note-2',
                        x: 400,
                        y: 150,
                        width: 180,
                        height: 120,
                        rotation: 2,
                        color: COLORS[2],
                        content: 'Drag to move notes\n\nResize with the handles'
                    },
                    {
                        id: 'note-3',
                        x: 300,
                        y: 300,
                        width: 220,
                        height: 180,
                        rotation: 1,
                        color: COLORS[4],
                        content: 'Click to select\n\nChange colors with the palette'
                    }
                ];
                
                setNotes(initialNotes);
                setNoteCounter(4);
            }, []);
            
            const createNewNote = useCallback((x, y) => {
                const newNote = {
                    id: `note-${noteCounter}`,
                    x: x - 100,
                    y: y - 75,
                    width: 200,
                    height: 150,
                    rotation: Math.random() * 10 - 5,
                    color: COLORS[Math.floor(Math.random() * COLORS.length)],
                    content: 'New idea...'
                };
                
                setNotes(prev => [...prev, newNote]);
                setSelectedNoteId(newNote.id);
                setNoteCounter(prev => prev + 1);
            }, [noteCounter]);
            
            const deleteNote = useCallback((id) => {
                setNotes(prev => prev.filter(note => note.id !== id));
                setConnections(prev => prev.filter(conn => conn.from !== id && conn.to !== id));
                if (selectedNoteId === id) setSelectedNoteId(null);
            }, [selectedNoteId]);
            
            const updateNotePosition = useCallback((id, x, y) => {
                setNotes(prev => prev.map(note => 
                    note.id === id ? { ...note, x, y } : note
                ));
            }, []);
            
            const updateNoteSize = useCallback((id, width, height) => {
                setNotes(prev => prev.map(note => 
                    note.id === id ? { ...note, width, height } : note
                ));
            }, []);
            
            const updateNoteRotation = useCallback((id, rotation) => {
                setNotes(prev => prev.map(note => 
                    note.id === id ? { ...note, rotation } : note
                ));
            }, []);
            
            const updateNoteColor = useCallback((id, color) => {
                setNotes(prev => prev.map(note => 
                    note.id === id ? { ...note, color } : note
                ));
            }, []);
            
            const updateNoteContent = useCallback((id, content) => {
                setNotes(prev => prev.map(note => 
                    note.id === id ? { ...note, content } : note
                ));
            }, []);
            
            const handleCanvasClick = (e) => {
                if (e.target === canvasRef.current) {
                    setSelectedNoteId(null);
                }
            };
            
            const handleCanvasDoubleClick = (e) => {
                if (e.target === canvasRef.current) {
                    const rect = canvasRef.current.getBoundingClientRect();
                    const x = (e.clientX - rect.left - position.x) / scale;
                    const y = (e.clientY - rect.top - position.y) / scale;
                    createNewNote(x, y);
                }
            };
            
            const handleNoteMouseDown = (e, id) => {
                e.stopPropagation();
                setSelectedNoteId(id);
                
                if (isConnecting) {
                    if (!connectionStartId) {
                        setConnectionStartId(id);
                    } else {
                        // Create connection
                        if (connectionStartId !== id) {
                            setConnections(prev => [
                                ...prev,
                                {
                                    from: connectionStartId,
                                    to: id,
                                    color: isDarkMode ? NEON_COLORS[Math.floor(Math.random() * NEON_COLORS.length)] : COLORS[Math.floor(Math.random() * COLORS.length)]
                                }
                            ]);
                        }
                        setIsConnecting(false);
                        setConnectionStartId(null);
                    }
                }
            };
            
            const handleNoteDoubleClick = (id) => {
                setFlippedNoteId(flippedNoteId === id ? null : id);
            };
            
            const handleResizeMouseDown = (e, id, direction) => {
                e.stopPropagation();
                e.preventDefault();
                
                const startX = e.clientX;
                const startY = e.clientY;
                const startWidth = notes.find(n => n.id === id).width;
                const startHeight = notes.find(n => n.id === id).height;
                const startRotation = notes.find(n => n.id === id).rotation;
                const startXPos = notes.find(n => n.id === id).x;
                const startYPos = notes.find(n => n.id === id).y;
                
                const handleMouseMove = (moveEvent) => {
                    const deltaX = moveEvent.clientX - startX;
                    const deltaY = moveEvent.clientY - startY;
                    
                    if (direction === 'rotate') {
                        const centerX = startXPos + startWidth / 2;
                        const centerY = startYPos + startHeight / 2;
                        const angle = Math.atan2(moveEvent.clientY - centerY, moveEvent.clientX - centerX) * (180 / Math.PI);
                        updateNoteRotation(id, angle);
                    } else {
                        let newWidth = startWidth;
                        let newHeight = startHeight;
                        let newX = startXPos;
                        let newY = startYPos;
                        
                        if (direction.includes('n')) {
                            newHeight = Math.max(50, startHeight - deltaY);
                            newY = startYPos + (startHeight - newHeight);
                        }
                        if (direction.includes('s')) {
                            newHeight = Math.max(50, startHeight + deltaY);
                        }
                        if (direction.includes('w')) {
                            newWidth = Math.max(50, startWidth - deltaX);
                            newX = startXPos + (startWidth - newWidth);
                        }
                        if (direction.includes('e')) {
                            newWidth = Math.max(50, startWidth + deltaX);
                        }
                        
                        updateNoteSize(id, newWidth, newHeight);
                        updateNotePosition(id, newX, newY);
                    }
                };
                
                const handleMouseUp = () => {
                    document.removeEventListener('mousemove', handleMouseMove);
                    document.removeEventListener('mouseup', handleMouseUp);
                };
                
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
            };
            
            const handleCanvasMouseDown = (e) => {
                if (e.button !== 0 || e.target !== canvasRef.current) return;
                
                setIsDraggingCanvas(true);
                setDragStart({
                    x: e.clientX - position.x,
                    y: e.clientY - position.y
                });
            };
            
            const handleCanvasMouseMove = (e) => {
                if (!isDraggingCanvas) return;
                
                setPosition({
                    x: e.clientX - dragStart.x,
                    y: e.clientY - dragStart.y
                });
            };
            
            const handleCanvasMouseUp = () => {
                setIsDraggingCanvas(false);
            };
            
            const handleWheel = (e) => {
                e.preventDefault();
                
                if (e.ctrlKey) {
                    // Zoom
                    const delta = -e.deltaY / 500;
                    const newScale = Math.min(Math.max(0.1, scale + delta), 3);
                    
                    // Zoom toward mouse position
                    const rect = canvasRef.current.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    const newX = mouseX - (mouseX - position.x) * (newScale / scale);
                    const newY = mouseY - (mouseY - position.y) * (newScale / scale);
                    
                    setScale(newScale);
                    setPosition({ x: newX, y: newY });
                } else {
                    // Pan
                    setPosition(prev => ({
                        x: prev.x - e.deltaX,
                        y: prev.y - e.deltaY
                    }));
                }
            };
            
            const handleKeyDown = (e) => {
                if (e.target.tagName === 'TEXTAREA') return;
                
                if (e.key === 'Delete' && selectedNoteId) {
                    deleteNote(selectedNoteId);
                } else if (e.key === 'n' && e.ctrlKey) {
                    createNewNote(window.innerWidth / 2, window.innerHeight / 2);
                } else if (e.key === 'c' && e.ctrlKey) {
                    setIsConnecting(!isConnecting);
                    setConnectionStartId(null);
                } else if (e.key === 'd' && e.ctrlKey) {
                    toggleDarkMode();
                } else if (e.key === 'm' && e.ctrlKey) {
                    setViewMode(prev => prev === 'board' ? 'mindmap' : 'board');
                } else if (e.key === 'a' && e.ctrlKey) {
                    arrangeNotesInGrid();
                } else if (e.key === 'r' && e.ctrlKey) {
                    scatterNotesRandomly();
                } else if (e.key === 'f' && e.ctrlKey) {
                    document.getElementById('search-input').focus();
                }
            };
            
            const toggleDarkMode = () => {
                setIsDarkMode(prev => !prev);
            };
            
            const arrangeNotesInGrid = () => {
                const gridSize = Math.ceil(Math.sqrt(notes.length));
                const noteWidth = 200;
                const noteHeight = 150;
                const padding = 50;
                
                const newNotes = notes.map((note, index) => {
                    const row = Math.floor(index / gridSize);
                    const col = index % gridSize;
                    
                    return {
                        ...note,
                        x: col * (noteWidth + padding) + 100,
                        y: row * (noteHeight + padding) + 100,
                        rotation: 0
                    };
                });
                
                setNotes(newNotes);
            };
            
            const scatterNotesRandomly = () => {
                const newNotes = notes.map(note => ({
                    ...note,
                    x: Math.random() * (window.innerWidth - 300),
                    y: Math.random() * (window.innerHeight - 200),
                    rotation: Math.random() * 20 - 10
                }));
                
                setNotes(newNotes);
            };
            
            const exportAsJSON = () => {
                const data = {
                    notes,
                    connections,
                    version: '1.0',
                    createdAt: new Date().toISOString()
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = 'dreamscape-ideas.json';
                a.click();
                
                URL.revokeObjectURL(url);
            };
            
            const exportAsImage = async () => {
                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Calculate bounds of all notes
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    
                    notes.forEach(note => {
                        minX = Math.min(minX, note.x);
                        minY = Math.min(minY, note.y);
                        maxX = Math.max(maxX, note.x + note.width);
                        maxY = Math.max(maxY, note.y + note.height);
                    });
                    
                    // Add padding
                    const padding = 50;
                    minX -= padding;
                    minY -= padding;
                    maxX += padding;
                    maxY += padding;
                    
                    const width = maxX - minX;
                    const height = maxY - minY;
                    
                    canvas.width = width;
                    canvas.height = height;
                    
                    // Draw background
                    ctx.fillStyle = isDarkMode ? '#111827' : '#FFFFFF';
                    ctx.fillRect(0, 0, width, height);
                    
                    // Draw grid
                    ctx.strokeStyle = isDarkMode ? 'rgba(255, 255, 255, 0.05)' : 'rgba(0, 0, 0, 0.05)';
                    ctx.lineWidth = 1;
                    
                    for (let x = 0; x < width; x += 40) {
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, height);
                        ctx.stroke();
                    }
                    
                    for (let y = 0; y < height; y += 40) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(width, y);
                        ctx.stroke();
                    }
                    
                    // Draw notes
                    notes.forEach(note => {
                        const x = note.x - minX;
                        const y = note.y - minY;
                        
                        // Draw note
                        ctx.save();
                        ctx.translate(x + note.width / 2, y + note.height / 2);
                        ctx.rotate(note.rotation * Math.PI / 180);
                        ctx.translate(-(x + note.width / 2), -(y + note.height / 2));
                        
                        ctx.fillStyle = isDarkMode ? (note.color === '#FFFFFF' ? '#1F2937' : note.color) : note.color;
                        ctx.strokeStyle = isDarkMode ? NEON_COLORS[COLORS.indexOf(note.color)] || '#00ffff' : 'rgba(0,0,0,0.1)';
                        ctx.lineWidth = 1;
                        
                        ctx.beginPath();
                        ctx.roundRect(x, y, note.width, note.height, 8);
                        ctx.fill();
                        ctx.stroke();
                        
                        // Draw text
                        ctx.fillStyle = isDarkMode ? '#FFFFFF' : '#000000';
                        ctx.font = '14px Inter';
                        ctx.textBaseline = 'top';
                        
                        const lines = note.content.split('\n');
                        const lineHeight = 18;
                        const padding = 12;
                        
                        lines.forEach((line, i) => {
                            ctx.fillText(line, x + padding, y + padding + (i * lineHeight));
                        });
                        
                        ctx.restore();
                    });
                    
                    // Draw connections
                    connections.forEach(conn => {
                        const fromNote = notes.find(n => n.id === conn.from);
                        const toNote = notes.find(n => n.id === conn.to);
                        
                        if (!fromNote || !toNote) return;
                        
                        const fromX = fromNote.x - minX + fromNote.width / 2;
                        const fromY = fromNote.y - minY + fromNote.height / 2;
                        const toX = toNote.x - minX + toNote.width / 2;
                        const toY = toNote.y - minY + toNote.height / 2;
                        
                        // Calculate control points for a smooth curve
                        const dx = toX - fromX;
                        const dy = toY - fromY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const controlX1 = fromX + dx * 0.3;
                        const controlY1 = fromY + dy * 0.3 + distance * 0.2;
                        const controlX2 = toX - dx * 0.3;
                        const controlY2 = toY - dy * 0.3 - distance * 0.2;
                        
                        ctx.strokeStyle = conn.color;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(fromX, fromY);
                        ctx.bezierCurveTo(controlX1, controlY1, controlX2, controlY2, toX, toY);
                        ctx.stroke();
                    });
                    
                    // Convert to image and download
                    const dataUrl = canvas.toDataURL('image/png');
                    const a = document.createElement('a');
                    a.href = dataUrl;
                    a.download = 'dreamscape-board.png';
                    a.click();
                } catch (error) {
                    console.error('Error exporting as image:', error);
                }
            };
            
            const filteredNotes = searchQuery 
                ? notes.filter(note => 
                    note.content.toLowerCase().includes(searchQuery.toLowerCase())
                )
                : notes;
            
            return (
                <div 
                    className="w-screen h-screen flex flex-col overflow-hidden select-none"
                    onKeyDown={handleKeyDown}
                    tabIndex="0"
                >
                    {/* Toolbar */}
                    <div className={`flex items-center justify-between p-3 ${isDarkMode ? 'bg-gray-800 text-white' : 'bg-white text-gray-800'} border-b ${isDarkMode ? 'border-gray-700' : 'border-gray-200'}`}>
                        <div className="flex items-center gap-2">
                            <h1 className="text-xl font-bold">DreamScape</h1>
                            <span className="text-xs opacity-70">v1.0</span>
                        </div>
                        
                        <div className="flex items-center gap-4">
                            <div className="relative">
                                <input
                                    id="search-input"
                                    type="text"
                                    placeholder="Search notes..."
                                    className={`px-3 py-1.5 rounded-md text-sm ${isDarkMode ? 'bg-gray-700 text-white placeholder-gray-400' : 'bg-gray-100 text-gray-800 placeholder-gray-500'}`}
                                    value={searchQuery}
                                    onChange={(e) => setSearchQuery(e.target.value)}
                                />
                                <i className={`fas fa-search absolute right-3 top-1/2 -translate-y-1/2 ${isDarkMode ? 'text-gray-400' : 'text-gray-500'}`}></i>
                            </div>
                            
                            <button 
                                className={`px-3 py-1.5 rounded-md text-sm flex items-center gap-2 ${isConnecting ? (isDarkMode ? 'bg-purple-600' : 'bg-purple-500 text-white') : (isDarkMode ? 'bg-gray-700' : 'bg-gray-100')}`}
                                onClick={() => setIsConnecting(!isConnecting)}
                            >
                                <i className="fas fa-link"></i>
                                <span>Connect</span>
                            </button>
                            
                            <button 
                                className={`px-3 py-1.5 rounded-md text-sm flex items-center gap-2 ${isDarkMode ? 'bg-gray-700' : 'bg-gray-100'}`}
                                onClick={toggleDarkMode}
                            >
                                <i className={`fas ${isDarkMode ? 'fa-sun' : 'fa-moon'}`}></i>
                                <span>{isDarkMode ? 'Light' : 'Dark'}</span>
                            </button>
                            
                            <div className="h-5 w-px bg-gray-300 dark:bg-gray-600"></div>
                            
                            <button 
                                className={`px-3 py-1.5 rounded-md text-sm flex items-center gap-2 ${isDarkMode ? 'bg-gray-700' : 'bg-gray-100'}`}
                                onClick={arrangeNotesInGrid}
                            >
                                <i className="fas fa-th"></i>
                                <span>Arrange</span>
                            </button>
                            
                            <button 
                                className={`px-3 py-1.5 rounded-md text-sm flex items-center gap-2 ${isDarkMode ? 'bg-gray-700' : 'bg-gray-100'}`}
                                onClick={scatterNotesRandomly}
                            >
                                <i className="fas fa-random"></i>
                                <span>Scatter</span>
                            </button>
                            
                            <div className="h-5 w-px bg-gray-300 dark:bg-gray-600"></div>
                            
                            <button 
                                className={`px-3 py-1.5 rounded-md text-sm flex items-center gap-2 ${isDarkMode ? 'bg-gray-700' : 'bg-gray-100'}`}
                                onClick={exportAsJSON}
                            >
                                <i className="fas fa-file-export"></i>
                                <span>Export JSON</span>
                            </button>
                            
                            <button 
                                className={`px-3 py-1.5 rounded-md text-sm flex items-center gap-2 ${isDarkMode ? 'bg-gray-700' : 'bg-gray-100'}`}
                                onClick={exportAsImage}
                            >
                                <i className="fas fa-image"></i>
                                <span>Export Image</span>
                            </button>
                        </div>
                    </div>
                    
                    {/* Canvas */}
                    <div 
                        ref={canvasRef}
                        className={`flex-1 relative overflow-hidden ${isDarkMode ? 'canvas-bg-dark bg-gray-900' : 'canvas-bg bg-gray-50'}`}
                        onClick={handleCanvasClick}
                        onDoubleClick={handleCanvasDoubleClick}
                        onMouseDown={handleCanvasMouseDown}
                        onMouseMove={handleCanvasMouseMove}
                        onMouseUp={handleCanvasMouseUp}
                        onMouseLeave={handleCanvasMouseUp}
                        onWheel={handleWheel}
                        style={{ cursor: isDraggingCanvas ? 'grabbing' : 'grab' }}
                    >
                        <motion.div 
                            className="absolute w-full h-full"
                            style={{
                                x: position.x,
                                y: position.y,
                                scale
                            }}
                        >
                            <AnimatePresence>
                                {filteredNotes.map(note => (
                                    <Note
                                        key={note.id}
                                        ref={el => noteRefs.current[note.id] = el}
                                        id={note.id}
                                        x={note.x}
                                        y={note.y}
                                        width={note.width}
                                        height={note.height}
                                        rotation={note.rotation}
                                        color={note.color}
                                        content={note.content}
                                        isSelected={selectedNoteId === note.id}
                                        isHighlighted={searchQuery && note.content.toLowerCase().includes(searchQuery.toLowerCase())}
                                        isDarkMode={isDarkMode}
                                        onMouseDown={handleNoteMouseDown}
                                        onDoubleClick={() => handleNoteDoubleClick(note.id)}
                                        onResize={handleResizeMouseDown}
                                        onDelete={deleteNote}
                                        onColorChange={updateNoteColor}
                                        onContentChange={updateNoteContent}
                                    />
                                ))}
                            </AnimatePresence>
                            
                            {connections.map((conn, index) => (
                                <ConnectionLine
                                    key={index}
                                    from={noteRefs.current[conn.from]}
                                    to={noteRefs.current[conn.to]}
                                    color={conn.color}
                                />
                            ))}
                            
                            {isConnecting && connectionStartId && noteRefs.current[connectionStartId] && (
                                <ConnectionLine
                                    from={noteRefs.current[connectionStartId]}
                                    to={{ getBoundingClientRect: () => ({
                                        left: position.x + (window.event?.clientX || 0),
                                        top: position.y + (window.event?.clientY || 0),
                                        width: 0,
                                        height: 0
                                    }) }}
                                    color={isDarkMode ? NEON_COLORS[0] : COLORS[0]}
                                />
                            )}
                        </motion.div>
                        
                        {/* Status bar */}
                        <div className={`absolute bottom-0 left-0 right-0 p-2 text-xs flex justify-between items-center ${isDarkMode ? 'bg-gray-800 text-gray-300' : 'bg-white text-gray-600'} border-t ${isDarkMode ? 'border-gray-700' : 'border-gray-200'}`}>
                            <div>
                                {notes.length} notes | {connections.length} connections | 
                                Zoom: {Math.round(scale * 100)}% | 
                                {isConnecting ? ' Connecting mode - click another note to connect' : ''}
                                {connectionStartId ? ' Select target note' : ''}
                            </div>
                            <div className="flex gap-4">
                                <span>Ctrl+N: New note</span>
                                <span>Ctrl+C: Connect mode</span>
                                <span>Ctrl+D: Toggle dark</span>
                                <span>Ctrl+F: Search</span>
                                <span>Delete: Remove note</span>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };
        
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<DreamScape />);
    </script>
</body>
</html>
